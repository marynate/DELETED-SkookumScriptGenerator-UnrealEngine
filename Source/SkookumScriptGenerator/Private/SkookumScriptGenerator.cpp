//=======================================================================================
// SkookumScript Unreal Engine Binding Generator
// Copyright (c) 2015 Agog Labs Inc. All rights reserved.
//
// Author: Markus Breyer
//
// Adapted in parts from sample code by Robert Manuszewski of Epic Games Inc.
//=======================================================================================
                                                    
#include "SkookumScriptGeneratorPrivatePCH.h"

//#define USE_DEBUG_LOG_FILE

DEFINE_LOG_CATEGORY(LogSkookumScriptGenerator);

class FSkookumScriptGenerator : public ISkookumScriptGenerator
  {
  
  //---------------------------------------------------------------------------------------
  // IModuleInterface implementation

  virtual void    StartupModule() override;
  virtual void    ShutdownModule() override;

  //---------------------------------------------------------------------------------------
  // IScriptGeneratorPluginInterface implementation

  virtual FString GetGeneratedCodeModuleName() const override { return TEXT("SkookumScriptRuntime"); }
  virtual bool    ShouldExportClassesForModule(const FString & module_name, EBuildModuleType::Type module_type, const FString & module_generated_include_folder) const;
  virtual bool    SupportsTarget(const FString & target_name) const override { return true; }
  virtual void    Initialize(const FString & root_local_path, const FString & root_build_path, const FString & output_directory, const FString & include_base) override;
  virtual void    ExportClass(UClass * class_p, const FString & source_header_file_name, const FString & generated_header_file_name, bool has_changed) override;
  virtual void    FinishExport() override;

  //---------------------------------------------------------------------------------------
  // Types

  enum eSkTypeID
    {
    SkTypeID_None = 0,
    SkTypeID_Integer,
    SkTypeID_Real,
    SkTypeID_Boolean,
    SkTypeID_String,
    SkTypeID_Name,
    SkTypeID_Vector2,
    SkTypeID_Vector3,
    SkTypeID_Vector4,
    SkTypeID_Rotation,
    SkTypeID_RotationAngles,
    SkTypeID_Transform,
    SkTypeID_Color,
    SkTypeID_UClass,
    SkTypeID_UObject,

    SkTypeID__Count
    };

  // To keep track of bindings generated for a particular class
  struct MethodBinding
    {
    void make_method(UFunction * function_p); // create names for a method
    void make_property_getter(UProperty * property_p);
    void make_property_setter(UProperty * property_p);

    bool operator == (const MethodBinding & other) const { return m_script_name == other.m_script_name; }

    FString   m_script_name;
    FString   m_code_name;
    };

  // To keep track of classes for later exporting
  struct ClassRecord
    {
    ClassRecord(UClass * class_p, const FString & source_header_file_name) : m_class_p(class_p), m_source_header_file_name(source_header_file_name) {}

    bool operator == (const ClassRecord & other) const { return m_class_p == other.m_class_p; }

    UClass *  m_class_p;
    FString   m_source_header_file_name;
    };

  //---------------------------------------------------------------------------------------
  // Data

  static const int32    ms_path_depth; // Amount of super classes until we start flattening the script file hierarchy due to the evil reign of Windows MAX_PATH. 1 = everything is right under 'Object', 0 is not allowed

  static const FString  ms_sk_type_id_names[SkTypeID__Count]; // Names belonging to the ids above
  static const FString  ms_reserved_keywords[]; // = Forbidden variable names

  FString               m_binding_code_path; // Output folder for generated binding code files
  FString               m_scripts_path; // Output folder for generated script files
  FString               m_unreal_engine_root_path_local; // Root of "Unreal Engine" folder on local machine
  FString               m_unreal_engine_root_path_build; // Root of "Unreal Engine" folder for builds - may be different to m_unreal_engine_root_local if we're building remotely
  FString               m_runtime_plugin_root_path; // Root of the runtime plugin we're generating the code for - used as base path for include files

  TArray<FString>       m_all_header_file_names; // Keep track of all headers generated
  TArray<FString>       m_all_binding_file_names; // Keep track of all binding files generated
  TArray<FString>       m_temp_headers; // Keep track of temp headers generated by save_header_if_changed()

  TSet<UClass *>        m_exported_classes; // Whenever a class gets exported, it gets added to this list
  TArray<ClassRecord>   m_extra_classes; // Classes rejected to export at first, but possibly exported later if ever used
  TArray<UClass *>      m_used_classes; // All classes used as types (by parameters, properties etc.)

#ifdef USE_DEBUG_LOG_FILE
  FILE *                m_debug_log_file; // Quick file handle to print debug stuff to, generates log file in output folder
#endif

  //---------------------------------------------------------------------------------------
  // Methods

  void                  generate_class(UClass * class_p, const FString & source_header_file_name); // Generate script and binding files for a class and its methods and properties
  void                  generate_class_script_files(UClass * class_p); // Generate script files for a class and its methods and properties 
  void                  generate_class_header_file(UClass * class_p, const FString & source_header_file_name); // Generate header file for a class
  void                  generate_class_binding_file(UClass * class_p); // Generate binding code source file for a class

  FString               generate_method(const FString & class_name_cpp, UClass * class_p, UFunction * function_p, const MethodBinding & binding); // Generate script file and binding code for a method
  void                  generate_method_script_file(UFunction * function_p, const FString & script_function_name); // Generate script file for a method
  FString               generate_method_binding_code(const FString & class_name_cpp, UClass * class_p, UFunction * function_p, const FString & code_function_name); // Generate binding code for a method

  FString               generate_property_getter(const FString & class_name_cpp, UClass * class_p, UProperty * property_p, int32 property_index, const MethodBinding & binding); // Generate getter script file and binding code for a property
  FString               generate_property_setter(const FString & class_name_cpp, UClass * class_p, UProperty * property_p, int32 property_index, const MethodBinding & binding); // Generate setter script file and binding code for a property
  void                  generate_property_getter_script_file(UProperty * property_p, const FString & script_function_name); // Generate getter script file for a property
  void                  generate_property_setter_script_file(UProperty * property_p, const FString & script_function_name); // Generate setter script file for a property
  FString               generate_property_getter_binding_code(UProperty * property_p, const FString & class_name_cpp, UClass * class_p, const FString & code_function_name); // Generate getter binding code for a property
  FString               generate_property_setter_binding_code(UProperty * property_p, const FString & class_name_cpp, UClass * class_p, const FString & code_function_name); // Generate setter binding code for a property

  FString               generate_method_binding_declaration(const FString & function_name, bool is_static); // Generate declaration of method binding function
  FString               generate_this_pointer_initialization(const FString & class_name_cpp, bool is_static); // Generate code that obtains the 'this' pointer from scope_p
  FString               generate_method_parameter_expression(UFunction * function_p, UProperty * param_p, int32 ParamIndex);
  FString               generate_return_value_passing(UClass * class_p, UFunction * function_p, UProperty * return_value_p, const FString & return_value_name); // Generate code that passes back the return value

  void                  generate_master_binding_file(); // Generate master source file that includes all others

  bool                  can_export_class(UClass * class_p, const FString & source_header_file_name) const;
  static bool           can_export_method(UClass * class_p, UFunction * function_p);
  static bool           can_export_property(UClass * class_p, UProperty * property_p);
  static bool           does_class_have_static_class(UClass * class_p);
  static bool           is_property_type_supported(UProperty * property_p);

  static FString        skookify_class_name(const FString & name);
  static FString        skookify_var_name(const FString & name, bool * is_boolean_p = nullptr);
  FString               get_skookum_class_path(UClass * class_p);
  static FString        get_skookum_class_name(UClass * class_p);
  static eSkTypeID      get_skookum_property_type(UProperty * property_p);
  FString               get_skookum_property_type_name(UProperty * property_p);
  static uint32         get_skookum_string_crc(const FString & string);
  FString               get_cpp_class_name(UClass * class_p);
  static FString        get_cpp_property_type_name(UProperty * property_p, uint32 port_flags = 0);

  bool                  save_header_if_changed(const FString & HeaderPath, const FString & new_header_contents); // Helper to change a file only if needed
  void                  rename_temp_files(); // Puts generated files into place after all code generation is done
  };

IMPLEMENT_MODULE( FSkookumScriptGenerator, SkookumScriptGenerator )

//=======================================================================================
// IModuleInterface implementation
//=======================================================================================

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::StartupModule()
  {
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::ShutdownModule()
  {
  }

//=======================================================================================
// IScriptGeneratorPluginInterface implementation
//=======================================================================================

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::Initialize(const FString & root_local_path, const FString & root_build_path, const FString & output_directory, const FString & include_base)
  {
  m_binding_code_path = output_directory;
  m_unreal_engine_root_path_local = root_local_path;
  m_unreal_engine_root_path_build = root_build_path;
  m_runtime_plugin_root_path = include_base;
  m_scripts_path = IFileManager::Get().ConvertToAbsolutePathForExternalAppForWrite(*(include_base / TEXT("../../Scripts/Engine-Generated")));

  // Clear contents of scripts folder for a fresh start
  FString directory_to_delete(m_scripts_path / TEXT("Object"));
  IFileManager::Get().DeleteDirectory(*directory_to_delete, false, true);

  // Create debug log file
  #ifdef USE_DEBUG_LOG_FILE
    m_debug_log_file = _wfopen(*(output_directory / TEXT("SkookumScriptGenerator.log.txt")), TEXT("w"));
  #endif
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::ShouldExportClassesForModule(const FString & module_name, EBuildModuleType::Type module_type, const FString & module_generated_include_folder) const
  { 
  bool can_export = (module_type == EBuildModuleType::Runtime || module_type == EBuildModuleType::Game);
  if (can_export)
    {
    // Only export functions from selected modules
    static struct FSupportedModules
      {
      TArray<FString> supported_script_modules;
      FSupportedModules()
        {
        GConfig->GetArray(TEXT("Plugins"), TEXT("ScriptSupportedModules"), supported_script_modules, GEngineIni);
        }
      } supported_modules;

    can_export = supported_modules.supported_script_modules.Num() == 0 || supported_modules.supported_script_modules.Contains(module_name);
    }
  return can_export;
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::ExportClass(UClass * class_p, const FString & source_header_file_name, const FString & generated_header_file_name, bool has_changed)
  {
  // $Revisit MBreyer - (for now) skip and forget classes coming from engine plugins
  if (source_header_file_name.Find(TEXT("Engine/Plugins")) >= 0)
    {
    return;
    }

  if (!can_export_class(class_p, source_header_file_name))
    {
    m_extra_classes.AddUnique(ClassRecord(class_p, source_header_file_name));
    return;
    }

  generate_class(class_p, source_header_file_name);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::FinishExport()
  {
  // Generate any classes that have been used but not exported yet
  for (auto & extra_class : m_extra_classes)
    {
    // Generate it if it's been used anywhere
    bool generate_it = (m_used_classes.Find(extra_class.m_class_p) >= 0);    

    // Or, if it's derived from any class already exported
    /*
    if (!generate_it)
      {
      for (UClass * class_p = extra_class.m_class_p; class_p && class_p != UObject::StaticClass(); class_p = class_p->GetSuperClass())
        {
        if (m_exported_classes.Contains(class_p))
          {
          generate_it = true;
          break;
          }
        }
      }
    */

    if (generate_it)
      {
      generate_class(extra_class.m_class_p, extra_class.m_source_header_file_name);
      }
    }

  generate_master_binding_file();
  rename_temp_files();

  #ifdef USE_DEBUG_LOG_FILE
    fclose(m_debug_log_file);
  #endif
  }

//=======================================================================================
// FSkookumScriptGenerator implementation
//=======================================================================================

const int32 FSkookumScriptGenerator::ms_path_depth = 4;

const FString FSkookumScriptGenerator::ms_sk_type_id_names[FSkookumScriptGenerator::SkTypeID__Count] =
  {
  TEXT("nil"),
  TEXT("Integer"),
  TEXT("Real"),
  TEXT("Boolean"),
  TEXT("String"),
  TEXT("Name"),
  TEXT("Vector2"),
  TEXT("Vector3"),
  TEXT("Vector4"),
  TEXT("Rotation"),
  TEXT("RotationAngles"),
  TEXT("Transform"),
  TEXT("Color"),
  TEXT("EntityClass"),  // UClass
  TEXT("Entity"),       // UObject
  };

const FString FSkookumScriptGenerator::ms_reserved_keywords[] =
  {
  TEXT("branch"),
  TEXT("case"),
  TEXT("divert"),
  TEXT("else"),
  TEXT("exit"),
  TEXT("false"),
  TEXT("fork"),
  TEXT("if"),
  TEXT("loop"),
  TEXT("nil"),
  TEXT("race"),
  TEXT("rush"),
  TEXT("skip"),
  TEXT("sync"),
  TEXT("this"),
  TEXT("this_class"),
  TEXT("this_code"),
  TEXT("true"),
  TEXT("unless"),
  TEXT("when"),

  // Boolean word operators
  TEXT("and"),
  TEXT("nand"),
  TEXT("nor"),
  TEXT("not"),
  TEXT("nxor"),
  TEXT("or"),
  TEXT("xor"),

  // C++ Reserved Words to watch for
  TEXT("break"),
  TEXT("continue"),
  TEXT("default"),
  TEXT("do"),
  TEXT("for"),
  TEXT("return"),
  TEXT("switch"),
  TEXT("while"),
  };

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_class(UClass * class_p, const FString & source_header_file_name)
  {
  UE_LOG(LogSkookumScriptGenerator, Log, TEXT("Generating class %s"), *get_skookum_class_name(class_p));

  m_exported_classes.Add(class_p);

  // Generate script files
  generate_class_script_files(class_p);

  // Generate binding code files	
  generate_class_header_file(class_p, source_header_file_name);
  generate_class_binding_file(class_p);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_class_script_files(UClass * class_p)
  {
  FString meta_file_path = get_skookum_class_path(class_p) / TEXT("!Class.sk-meta");

  // Create class default files:
  if (!FFileHelper::SaveStringToFile(FString(), *meta_file_path))
    {
    FError::Throwf(TEXT("Could not save file: %s"), *meta_file_path);
    }
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_class_header_file(UClass * class_p, const FString & source_header_file_name)
  {
  const FString class_header_file_name = FString::Printf(TEXT("SSUE%s.generated.hpp"), *get_skookum_class_name(class_p));
  m_all_header_file_names.Add(class_header_file_name);

  FString skookum_class_name = get_skookum_class_name(class_p);
  FString cpp_class_name = get_cpp_class_name(class_p);

  FString generated_code;

  generated_code += TEXT("#pragma once\r\n\r\n");

  // if not defined let's hope it is already known when the compiler gets here
  if (source_header_file_name.Len() > 0)
    {
    FString relative_path(source_header_file_name);
    FPaths::MakePathRelativeTo(relative_path, *m_runtime_plugin_root_path);
    generated_code += FString::Printf(TEXT("#include \"%s\"\r\n\r\n"), *relative_path);
    }
  else
    {
    generated_code += FString::Printf(TEXT("// Note: Include path for %s was unknown at code generation time, so hopefully the class is already known when compilation gets here\r\n\r\n"), *cpp_class_name);
    }

  generated_code += TEXT("class ASymbol;\r\nclass SSClass;\r\nclass SSInstance;\r\n\r\n");

  generated_code += FString::Printf(TEXT("template<> inline %s * SSUserDataBase::as<%s>() const { return static_cast<%s *>(as_stored<FWeakObjectPtr>()->Get()); }\r\n"), *cpp_class_name, *cpp_class_name, *cpp_class_name);
  generated_code += FString::Printf(TEXT("template<> inline void SSUserDataBase::set(%s * const & obj_p) { *as_stored<FWeakObjectPtr>() = obj_p; }\r\n"), *cpp_class_name);

  generated_code += FString::Printf(TEXT("\r\nnamespace SSUE%s\r\n  {\r\n\r\n"), *skookum_class_name);

  generated_code += TEXT("  extern ASymbol    g_class_name;\r\n");
  generated_code += TEXT("  extern SSClass *  g_class_p;\r\n");
  generated_code += TEXT("  extern UClass *   g_uclass_p;\r\n");
  generated_code += TEXT("\r\n");
  generated_code += TEXT("  void          register_bindings();\r\n");
  generated_code += FString::Printf(TEXT("  SSInstance *  as_instance(%s * const &);\r\n"), *cpp_class_name);

  generated_code += FString::Printf(TEXT("\r\n  } // SSUE%s\r\n"), *skookum_class_name);

  save_header_if_changed(m_binding_code_path / class_header_file_name, generated_code);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_class_binding_file(UClass * class_p)
  {
  const FString skookum_class_name = get_skookum_class_name(class_p);
  const FString class_binding_file_name = FString::Printf(TEXT("SSUE%s.generated.inl"), *skookum_class_name);
  m_all_binding_file_names.Add(class_binding_file_name);

  const FString class_name_cpp = get_cpp_class_name(class_p);

  enum eScope { Scope_instance, Scope_class }; // 0 = instance, 1 = static bindings
  TArray<MethodBinding> bindings[2]; // eScope
  MethodBinding binding;

  FString generated_code;
  generated_code += FString::Printf(TEXT("\r\nnamespace SSUE%s\r\n  {\r\n\r\n"), *skookum_class_name);

  // data members
  generated_code += TEXT("  SSClass * g_class_p = nullptr;\r\n  ASymbol   g_class_name;\r\n  UClass *  g_uclass_p = nullptr;\r\n\r\n");

  // Export all functions
  for (TFieldIterator<UFunction> FuncIt(class_p /*, EFieldIteratorFlags::ExcludeSuper */); FuncIt; ++FuncIt)
    {
    UFunction * function_p = *FuncIt;
    if (can_export_method(class_p, function_p))
      {
      binding.make_method(function_p);
      check(bindings[Scope_instance].Find(binding) < 0 && bindings[Scope_class].Find(binding) < 0); // must be unique here
      generated_code += generate_method(class_name_cpp, class_p, function_p, binding);
      bindings[function_p->HasAnyFunctionFlags(FUNC_Static) ? Scope_class : Scope_instance].Push(binding);
      }
    }

  // Export properties that are owned by this class
  int32 property_index = 0;
  for (TFieldIterator<UProperty> property_it(class_p /*, EFieldIteratorFlags::ExcludeSuper */); property_it; ++property_it, ++property_index)
    {
    UProperty * property_p = *property_it;
    if (can_export_property(class_p, property_p))
      {
      UE_LOG(LogSkookumScriptGenerator, Log, TEXT("  %s %s"), *property_p->GetClass()->GetName(), *property_p->GetName());

      binding.make_property_getter(property_p);
      if (bindings[Scope_instance].Find(binding) < 0)
        { // Only generate property accessor if not covered by a method already
        generated_code += generate_property_getter(class_name_cpp, class_p, property_p, property_index, binding);
        bindings[Scope_instance].Push(binding);
        }

      if (property_p->PropertyFlags & CPF_Edit)
        {
        binding.make_property_setter(property_p);
        if (bindings[Scope_instance].Find(binding) < 0)
          { // Only generate property accessor if not covered by a method already
          generated_code += generate_property_setter(class_name_cpp, class_p, property_p, property_index, binding);
          bindings[Scope_instance].Push(binding);
          }
        }
      }
    }

  // Binding array
  for (uint32 scope = 0; scope < 2; ++scope)
    {
    if (bindings[scope].Num() > 0)
      {
      generated_code += FString::Printf(TEXT("  static const SSClass::MethodInitializerFuncId methods_%c[] =\r\n    {\r\n"), scope ? TCHAR('c') : TCHAR('i'));
      for (auto & binding : bindings[scope])
        {
        generated_code += FString::Printf(TEXT("      { 0x%08x, mthd%s_%s },\r\n"), get_skookum_string_crc(*binding.m_script_name), scope ? TEXT("c") : TEXT(""), *binding.m_code_name);
        }
      generated_code += TEXT("    };\r\n\r\n");
      }
    }

  // Register bindings function
  generated_code += TEXT("  void register_bindings()\r\n    {\r\n");
  generated_code += FString::Printf(TEXT("    g_class_name = ASymbol::create_existing(0x%08x); // \"%s\"\r\n"), get_skookum_string_crc(*skookum_class_name), *skookum_class_name);
  generated_code += TEXT("    g_class_p = SSBrain::get_class(g_class_name);\r\n");

  // Only set g_uclass_p if DLL exported
  if (does_class_have_static_class(class_p))
    {
    generated_code += FString::Printf(TEXT("    g_uclass_p = %s::StaticClass();\r\n"), *class_name_cpp);
    }
  else
    {
    generated_code += FString::Printf(TEXT("    g_uclass_p = FindObject<UClass>(ANY_PACKAGE, TEXT(\"%s\"));\r\n"), *class_p->GetName());
    }

  for (uint32 scope = 0; scope < 2; ++scope)
    {
    if (bindings[scope].Num() > 0)
      {
      generated_code += FString::Printf(TEXT("    g_class_p->register_method_func_bulk(methods_%c, %d, %s);\r\n"), scope ? TCHAR('c') : TCHAR('i'), bindings[scope].Num(), scope ? TEXT("SSBindFlag_class_no_rebind") : TEXT("SSBindFlag_instance_no_rebind"));
      }
    }
  generated_code += TEXT("    }\r\n");

  // as_instance function
  generated_code += FString::Printf(TEXT("\r\n  SSInstance * as_instance(%s * const & obj_p)\r\n    {\r\n"), *class_name_cpp);
  if (class_p->HasAnyCastFlag(CASTCLASS_AActor))
    {
    generated_code += TEXT("    return SSUE::get_actor_instance(obj_p, g_uclass_p, g_class_p);\r\n");
    }
  else
    {
    generated_code += TEXT("    return SSUE::get_object_instance(obj_p, g_uclass_p, g_class_p);\r\n");
    }
  generated_code += TEXT("    }\r\n");

  //generated_code += ExportAdditionalClassGlue(class_name_cpp, class_p);

  generated_code += FString::Printf(TEXT("\r\n  } // SSUE%s\r\n"), *get_skookum_class_name(class_p));

  save_header_if_changed(m_binding_code_path / class_binding_file_name, generated_code);
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_method(const FString & class_name_cpp, UClass * class_p, UFunction * function_p, const MethodBinding & binding)
  {
  // Generate script file
  generate_method_script_file(function_p, binding.m_script_name);

  // Generate binding code
  return generate_method_binding_code(class_name_cpp, class_p, function_p, binding.m_code_name);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_method_script_file(UFunction * function_p, const FString & script_function_name)
  {
  // Get file path of function
  bool is_static = function_p->HasAnyFunctionFlags(FUNC_Static);
  FString function_file_path = get_skookum_class_path(function_p->GetOwnerClass()) / (script_function_name.Replace(TEXT("?"), TEXT("-Q")) + (is_static ? TEXT("()C.sk") : TEXT("().sk")));

  // Generate function content
  FString function_body;
  function_body.Reserve(1024);
  bool has_params_or_return_value = (function_p->Children != NULL);
  if (has_params_or_return_value)
    {
    function_body += TEXT("(");

    FString separator;
    FString return_type_name;
    for (TFieldIterator<UProperty> param_it(function_p); param_it; ++param_it)
      {
      UProperty * param_p = *param_it;
      if (param_p->GetPropertyFlags() & CPF_ReturnParm)
        {
        return_type_name = TEXT(" ") + get_skookum_property_type_name(param_p);
        }
      else
        {
        function_body += separator + get_skookum_property_type_name(param_p) + TEXT(" ") + skookify_var_name(param_p->GetName());
        }
      separator = TEXT(", ");
      }

    function_body += TEXT(")") + return_type_name + TEXT("\n");
    }
  else
    {
    function_body = TEXT("()\n");
    }

  // Create script file
  if (!FFileHelper::SaveStringToFile(function_body, *function_file_path))
    {
    FError::Throwf(TEXT("Could not save file: %s"), *function_file_path);
    }
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_method_binding_code(const FString & class_name_cpp, UClass * class_p, UFunction * function_p, const FString & code_function_name)
  {
  UProperty * return_value_p = NULL;
  
  bool is_static = function_p->HasAnyFunctionFlags(FUNC_Static);

  FString function_body;
  function_body += FString::Printf(TEXT("    %s\r\n"), *generate_this_pointer_initialization(class_name_cpp, is_static));

  FString params;

  const bool bHasParamsOrReturnValue = (function_p->Children != NULL);
  if (bHasParamsOrReturnValue)
    {
    params += TEXT("    struct FDispatchParams\r\n      {\r\n");

    for (TFieldIterator<UProperty> param_it(function_p); param_it; ++param_it)
      {
      UProperty * param = *param_it;
      params += FString::Printf(TEXT("      %s %s;\r\n"), *get_cpp_property_type_name(param, CPPF_ArgumentOrReturnValue), *param->GetName());
      }
    params += TEXT("      } params;\r\n");
    int32 ParamIndex = 0;
    for (TFieldIterator<UProperty> param_it(function_p); param_it; ++param_it, ++ParamIndex)
      {
      UProperty * param_p = *param_it;
      params += FString::Printf(TEXT("    params.%s = %s;\r\n"), *param_p->GetName(), *generate_method_parameter_expression(function_p, param_p, ParamIndex));
      }
    }

  params += FString::Printf(TEXT("    static UFunction * function_p = this_p->FindFunctionChecked(TEXT(\"%s\"));\r\n"), *function_p->GetName());

  if (bHasParamsOrReturnValue)
    {
    params += TEXT("    check(function_p->ParmsSize <= sizeof(FDispatchParams));\r\n");
    params += TEXT("    this_p->ProcessEvent(function_p, &params);\r\n");
    }
  else
    {
    params += TEXT("    this_p->ProcessEvent(function_p, nullptr);\r\n");
    }

  function_body += params;

  FString function_call_argumants;
  FString return_value_declaration;
  for (TFieldIterator<UProperty> param_it(function_p); !return_value_p && param_it; ++param_it)
    {
    UProperty * param_p = *param_it;
    if (param_p->GetPropertyFlags() & CPF_ReturnParm)
      {
      return_value_p = param_p;
      }
    }
  if (return_value_p)
    {
    FString return_value_name = FString::Printf(TEXT("params.%s"), *return_value_p->GetName());
    function_body += FString::Printf(TEXT("    %s\r\n"), *generate_return_value_passing(class_p, function_p, return_value_p, *return_value_name));
    }

  FString generated_code = FString::Printf(TEXT("  %s\r\n    {\r\n"), *generate_method_binding_declaration(*code_function_name, is_static));
  generated_code += function_body;
  generated_code += TEXT("    }\r\n\r\n");

  return generated_code;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_property_getter(const FString & class_name_cpp, UClass * class_p, UProperty * property_p, int32 property_index, const MethodBinding & binding)
  {
  // Generate script file
  generate_property_getter_script_file(property_p, binding.m_script_name);

  // Generate binding code
  return generate_property_getter_binding_code(property_p, class_name_cpp, class_p, binding.m_code_name);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_property_getter_script_file(UProperty * property_p, const FString & script_function_name)
  {
  FString file_name = script_function_name.Replace(TEXT("?"), TEXT("-Q")) + TEXT("().sk");
  FString class_path = get_skookum_class_path(property_p->GetOwnerClass());
  FString body = TEXT("() ") + get_skookum_property_type_name(property_p) + TEXT("\n");
  FString path = class_path / file_name;
  if (!FFileHelper::SaveStringToFile(body, *path))
    {
    FError::Throwf(TEXT("Could not save file: %s"), *path);
    }
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_property_getter_binding_code(UProperty * property_p, const FString & class_name_cpp, UClass * class_p, const FString & code_function_name)
  {
  FString generated_code;

  generated_code += FString::Printf(TEXT("  %s\r\n    {\r\n"), *generate_method_binding_declaration(code_function_name, false));
  generated_code += FString::Printf(TEXT("    %s\r\n"), *generate_this_pointer_initialization(class_name_cpp, false));
  generated_code += FString::Printf(TEXT("    static UProperty * property_p = SSUE::find_class_property(g_uclass_p, TEXT(\"%s\"));\r\n"), *property_p->GetName());
  generated_code += FString::Printf(TEXT("    %s property_value;\r\n"), *get_cpp_property_type_name(property_p, CPPF_ArgumentOrReturnValue));
  generated_code += TEXT("    property_p->CopyCompleteValue(&property_value, property_p->ContainerPtrToValuePtr<void>(this_p));\r\n");
  generated_code += FString::Printf(TEXT("    %s\r\n"), *generate_return_value_passing(class_p, NULL, property_p, TEXT("property_value")));
  generated_code += TEXT("    }\r\n\r\n");

  return generated_code;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_property_setter(const FString & class_name_cpp, UClass * class_p, UProperty * property_p, int32 property_index, const MethodBinding & binding)
  {
  // Generate script files
  generate_property_setter_script_file(property_p, binding.m_script_name);

  // Generate binding code
  return generate_property_setter_binding_code(property_p, class_name_cpp, class_p, binding.m_code_name);
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_property_setter_script_file(UProperty * property_p, const FString & script_function_name)
  {
  FString var_name = skookify_var_name(property_p->GetName());
  FString file_name = script_function_name + TEXT("().sk");
  FString class_path = get_skookum_class_path(property_p->GetOwnerClass());
  FString body = TEXT("(") + get_skookum_property_type_name(property_p) + TEXT(" ") + var_name + TEXT(")\n");
  FString path = class_path / file_name;
  if (!FFileHelper::SaveStringToFile(body, *path))
    {
    FError::Throwf(TEXT("Could not save file: %s"), *path);
    }
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_property_setter_binding_code(UProperty * property_p, const FString & class_name_cpp, UClass * class_p, const FString & code_function_name)
  {
  FString generated_code;

  generated_code += FString::Printf(TEXT("  %s\r\n    {\r\n"), *generate_method_binding_declaration(code_function_name, false));
  generated_code += FString::Printf(TEXT("    %s\r\n"), *generate_this_pointer_initialization(class_name_cpp, false));
  generated_code += FString::Printf(TEXT("    static UProperty * property_p = SSUE::find_class_property(g_uclass_p, TEXT(\"%s\"));\r\n"), *property_p->GetName());
  generated_code += FString::Printf(TEXT("    %s property_value = %s;\r\n"), *get_cpp_property_type_name(property_p, CPPF_ArgumentOrReturnValue), *generate_method_parameter_expression(NULL, property_p, 0));
  generated_code += TEXT("    property_p->CopyCompleteValue(property_p->ContainerPtrToValuePtr<void>(this_p), &property_value);\r\n");
  generated_code += TEXT("    }\r\n\r\n");

  return generated_code;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_method_binding_declaration(const FString & function_name, bool is_static)
  {
  return FString::Printf(TEXT("static void mthd%s_%s(SSInvokedMethod * scope_p, SSInstance ** result_pp)"), is_static ? TEXT("c") : TEXT(""), *function_name);
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_this_pointer_initialization(const FString & class_name_cpp, bool is_static)
  {
  return FString::Printf(is_static ? TEXT("%s * this_p = GetMutableDefault<%s>(g_uclass_p);") : TEXT("%s * this_p = scope_p->this_as<%s>();"), *class_name_cpp, *class_name_cpp);
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_method_parameter_expression(UFunction * function_p, UProperty * param_p, int32 ParamIndex)
  {
  if (!(param_p->GetPropertyFlags() & CPF_ReturnParm))
    {
    FString Initializer;

    eSkTypeID type_id = get_skookum_property_type(param_p);
    switch (type_id)
      {
      case SkTypeID_Integer:         Initializer = TEXT("int(*scope_p->get_arg<SSIntegerType>(SSArg_%d))"); break;
      case SkTypeID_Real:            Initializer = TEXT("float(*scope_p->get_arg<SSRealType>(SSArg_%d))"); break;
      case SkTypeID_Boolean:         Initializer = TEXT("*scope_p->get_arg<SSBooleanType>(SSArg_%d)"); break;
      case SkTypeID_String:          Initializer = TEXT("FString(scope_p->get_arg<AString>(SSArg_%d)->as_cstr())"); break; // $revisit MBreyer - Avoid copy here
      case SkTypeID_Name:            Initializer = TEXT("*scope_p->get_arg<FName>(SSArg_%d)"); break;
      case SkTypeID_Vector2:         Initializer = TEXT("*scope_p->get_arg<FVector2D>(SSArg_%d)"); break;
      case SkTypeID_Vector3:         Initializer = TEXT("*scope_p->get_arg<FVector>(SSArg_%d)"); break;
      case SkTypeID_Vector4:         Initializer = TEXT("*scope_p->get_arg<FVector4>(SSArg_%d)"); break;
      case SkTypeID_Rotation:        Initializer = TEXT("*scope_p->get_arg<FQuat>(SSArg_%d)"); break;
      case SkTypeID_RotationAngles:  Initializer = TEXT("*scope_p->get_arg<FRotator>(SSArg_%d)"); break;
      case SkTypeID_Transform:       Initializer = TEXT("*scope_p->get_arg<FTransform>(SSArg_%d)"); break;
      case SkTypeID_Color:           Initializer = TEXT("*scope_p->get_arg<FLinearColor>(SSArg_%d)"); break;
      case SkTypeID_UClass:          Initializer = TEXT("scope_p->get_arg<UClass>(SSArg_%d)"); break;
      case SkTypeID_UObject:         Initializer = get_cpp_property_type_name(param_p, CPPF_ArgumentOrReturnValue); Initializer.RemoveFromEnd(TEXT("*")); Initializer = FString::Printf(TEXT("scope_p->get_arg<%s>(SSArg_%%d)"), *Initializer); break;
      default:                       FError::Throwf(TEXT("Unsupported function param type: %s"), *param_p->GetClass()->GetName()); break;
      }

    return FString::Printf(*Initializer, ParamIndex + 1);
    }
  else if (param_p->IsA(UObjectPropertyBase::StaticClass()) || param_p->IsA(UClassProperty::StaticClass()))
    {
    return TEXT("nullptr");
    }
  else
    {
    return FString::Printf(TEXT("%s()"), *get_cpp_property_type_name(param_p, CPPF_ArgumentOrReturnValue));
    }
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::generate_return_value_passing(UClass * class_p, UFunction * function_p, UProperty * return_value_p, const FString & return_value_name)
  {
  if (return_value_p)
    {
    FString fmt;

    eSkTypeID type_id = get_skookum_property_type(return_value_p);
    switch (type_id)
      {
      case SkTypeID_Integer:         fmt = TEXT("SSInteger::as_instance(%s)"); break;
      case SkTypeID_Real:            fmt = TEXT("SSReal::as_instance(%s)"); break;
      case SkTypeID_Boolean:         fmt = TEXT("SSBoolean::pool_new(%s)"); break;
      case SkTypeID_String:          fmt = TEXT("SSString::as_instance(AString(*%s, %s.Len()))"); break; // $revisit MBreyer - Avoid copy here
      case SkTypeID_Name:            fmt = TEXT("SSUEName::as_instance(%s)"); break;
      case SkTypeID_Vector2:         fmt = TEXT("SSVector2::as_instance(%s)"); break;
      case SkTypeID_Vector3:         fmt = TEXT("SSVector3::as_instance(%s)"); break;
      case SkTypeID_Vector4:         fmt = TEXT("SSVector4::as_instance(%s)"); break;
      case SkTypeID_Rotation:        fmt = TEXT("SSRotation::as_instance(%s)"); break;
      case SkTypeID_RotationAngles:  fmt = TEXT("SSRotationAngles::as_instance(%s)"); break;
      case SkTypeID_Transform:       fmt = TEXT("SSTransform::as_instance(%s)"); break;
      case SkTypeID_Color:           fmt = TEXT("SSColor::as_instance(%s)"); break;
      case SkTypeID_UClass:          fmt = TEXT("SSUEEntityClass::as_instance(%s)"); break;
      case SkTypeID_UObject:         fmt = FString::Printf(TEXT("SSUE%s::as_instance(%%s)"), *get_skookum_property_type_name(return_value_p)); break;
      default:                       FError::Throwf(TEXT("Unsupported return param type: %s"), *return_value_p->GetClass()->GetName()); break;
      }

    FString initializer = FString::Printf(*fmt, *return_value_name, *return_value_name);
    return FString::Printf(TEXT("if (result_pp) *result_pp = %s;"), *initializer);
    }
  else
    {
    return TEXT(""); // TEXT("if (result_pp) *result_pp = SSBrain::ms_nil_p;");
    }
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::generate_master_binding_file()
  {
  FString generated_code;

  generated_code += TEXT("\r\n");

  generated_code += TEXT("#include \"SkookumScript/SSClass.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSBrain.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSInvokedMethod.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSInteger.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSReal.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSBoolean.hpp\"\r\n");
  generated_code += TEXT("#include \"SkookumScript/SSString.hpp\"\r\n");

  generated_code += TEXT("\r\n");

  // Include all headers
  for (auto & header_file_name : m_all_header_file_names)
    {
    // Re-base to make sure we're including the right files on a remote machine
    FString NewFilename(FPaths::GetCleanFilename(header_file_name));
    generated_code += FString::Printf(TEXT("#include \"%s\"\r\n"), *NewFilename);
    }

  generated_code += TEXT("\r\n");

  // Include all bindings
  for (auto & binding_file_name : m_all_binding_file_names)
    {
    // Re-base to make sure we're including the right files on a remote machine
    FString NewFilename(FPaths::GetCleanFilename(binding_file_name));
    generated_code += FString::Printf(TEXT("#include \"%s\"\r\n"), *NewFilename);
    }

  generated_code += TEXT("\r\nnamespace SSUE\r\n  {\r\n\r\n");

  generated_code += TEXT("  void register_bindings()\r\n    {\r\n");
  for (auto class_p : m_exported_classes)
    {
    generated_code += FString::Printf(TEXT("    SSUE%s::register_bindings();\r\n"), *get_skookum_class_name(class_p));
    }
  generated_code += FString::Printf(TEXT("\r\n    g_class_map_u2s.Reset();\r\n    g_class_map_u2s.Reserve(%d);\r\n"), m_exported_classes.Num());
  for (auto class_p : m_exported_classes)
    {
    generated_code += FString::Printf(TEXT("    g_class_map_u2s.Add(SSUE%s::g_uclass_p, SSUE%s::g_class_p);\r\n"), *get_skookum_class_name(class_p), *get_skookum_class_name(class_p));
    }
  generated_code += FString::Printf(TEXT("\r\n    g_class_map_s2u.Reset();\r\n    g_class_map_s2u.Reserve(%d);\r\n"), m_exported_classes.Num());
  for (auto class_p : m_exported_classes)
    {
    generated_code += FString::Printf(TEXT("    g_class_map_s2u.Add(SSUE%s::g_class_p, SSUE%s::g_uclass_p);\r\n"), *get_skookum_class_name(class_p), *get_skookum_class_name(class_p));
    }
  generated_code += TEXT("\r\n    }\r\n");

  generated_code += TEXT("\r\n  } // SSUE\r\n");

  FString master_binding_file_name = m_binding_code_path / TEXT("SSUE.generated.inl");
  save_header_if_changed(master_binding_file_name, generated_code);
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::can_export_class(UClass * class_p, const FString & source_header_file_name) const
  {
  return does_class_have_static_class(class_p) // Don't export classes that don't export DLL symbols
    && !m_exported_classes.Contains(class_p); // Don't export classes that have already been exported
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::can_export_method(UClass * class_p, UFunction * function_p)
  {
  // If this function is inherited, do nothing as SkookumScript will inherit it for us
  if (function_p->GetOwnerClass() != class_p)
    return false;

  // We don't support delegates and non-public functions
  if ((function_p->FunctionFlags & FUNC_Delegate))
    {
    return false;
    }

  // Reject if any of the parameter types is unsupported yet
  for (TFieldIterator<UProperty> param_it(function_p); param_it; ++param_it)
    {
    UProperty * param_p = *param_it;

    if (param_p->IsA(UArrayProperty::StaticClass()) ||
      param_p->ArrayDim > 1 ||
      param_p->IsA(UDelegateProperty::StaticClass()) ||
      param_p->IsA(UMulticastDelegateProperty::StaticClass()) ||
      param_p->IsA(UWeakObjectProperty::StaticClass()) ||
      param_p->IsA(UInterfaceProperty::StaticClass()))
      {
      return false;
      }

    if (!is_property_type_supported(param_p))
      {
      return false;
      }
    }

  return true;
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::can_export_property(UClass * class_p, UProperty * property_p)
  {
  // If this property is inherited, do nothing as SkookumScript will inherit it for us
  if (property_p->GetOwnerClass() != class_p)
    return false;

  // Check if property type is supported
  return is_property_type_supported(property_p);
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::does_class_have_static_class(UClass * class_p)
  {
  return !!(class_p->ClassFlags & (CLASS_RequiredAPI | CLASS_MinimalAPI));
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::is_property_type_supported(UProperty * property_p)
  {
  if (property_p->IsA(ULazyObjectProperty::StaticClass())
    || property_p->IsA(UAssetObjectProperty::StaticClass())
    || property_p->IsA(UAssetClassProperty::StaticClass())
    || property_p->IsA(UWeakObjectProperty::StaticClass()))
    {
    return false;
    }

  return (get_skookum_property_type(property_p) != SkTypeID_None);
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::skookify_class_name(const FString & name)
  {
  if (name == TEXT("Object")) return TEXT("Entity");
  if (name == TEXT("Class"))  return TEXT("EntityClass");
  if (name == TEXT("Enum"))   return TEXT("Enum2"); // HACK

  return name;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::skookify_var_name(const FString & name, bool * is_boolean_p)
  {
  if (name.IsEmpty()) return name;

  // Change title case to lower case with underscores
  FString skookum_name;
  skookum_name.Reserve(name.Len() + 16);
  bool is_boolean = name[0] == 'b' && isupper(name[1]);
  bool was_upper = true;
  bool was_underscore = true;
  for (int32 i = int32(is_boolean); i < name.Len(); ++i)
    {
    TCHAR c = name[i];
    bool is_upper = isupper(c) != 0 || isdigit(c) != 0;
    if (is_upper && !was_upper && !was_underscore)
      {
      skookum_name.AppendChar('_');
      }
    skookum_name.AppendChar(tolower(c));
    was_upper = is_upper;
    was_underscore = (c == TCHAR('_'));
    }

  // Check for reserved keywords and append underscore if found
  for (uint32 i = 0; i < sizeof(ms_reserved_keywords) / sizeof(ms_reserved_keywords[0]); ++i)
    {
    if (skookum_name == ms_reserved_keywords[i])
      {
      skookum_name.AppendChar('_');
      break;
      }
    }

  if (is_boolean_p) *is_boolean_p = is_boolean;
  return skookum_name;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::get_skookum_class_path(UClass * class_p)
  {
  // Remember class name
  FString class_name = skookify_class_name(class_p->GetName());

  // Make array of the super classes
  TArray<UClass *> super_class_stack;
  super_class_stack.Reserve(32);
  while ((class_p = class_p->GetSuperClass()) != nullptr)
    {
    super_class_stack.Push(class_p);
    m_used_classes.AddUnique(class_p); // all super classes are also considered used
    }

  // Build path
  int32 max_super_class_nesting = FMath::Max(ms_path_depth - 1, 0);
  FString class_path = m_scripts_path / TEXT("Object");
  for (int32 i = 0; i < max_super_class_nesting && super_class_stack.Num(); ++i)
    {
    class_path /= skookify_class_name(super_class_stack.Pop()->GetName());
    }
  if (super_class_stack.Num())
    {
    class_name = skookify_class_name(super_class_stack[0]->GetName()) + TEXT(".") + class_name;
    }
  return class_path / class_name;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::get_skookum_class_name(UClass * class_p)
  {
  return skookify_class_name(class_p->GetName());
  }

//---------------------------------------------------------------------------------------

FSkookumScriptGenerator::eSkTypeID FSkookumScriptGenerator::get_skookum_property_type(UProperty * property_p)
  {
  // Check for simple types first
  if (property_p->IsA(UIntProperty::StaticClass()))         return SkTypeID_Integer;
  if (property_p->IsA(UFloatProperty::StaticClass()))       return SkTypeID_Real;
  if (property_p->IsA(UStrProperty::StaticClass()))         return SkTypeID_String;
  if (property_p->IsA(UNameProperty::StaticClass()))        return SkTypeID_Name;
  if (property_p->IsA(UBoolProperty::StaticClass()))        return SkTypeID_Boolean;

  // Any known struct?
  if (property_p->IsA(UStructProperty::StaticClass()))
    {
    // Supported structs
    static FName name_Vector2D("Vector2D");
    static FName name_Vector("Vector");
    static FName name_Vector4("Vector4");
    static FName name_Quat("Quat");
    static FName name_Rotator("Rotator");
    static FName name_Transform("Transform");
    static FName name_LinearColor("LinearColor");
    static FName name_Color("Color");

    UStructProperty * struct_prop_p = CastChecked<UStructProperty>(property_p);
    const FName struct_name = struct_prop_p->Struct->GetFName();

    if (struct_name == name_Vector2D)     return SkTypeID_Vector2;
    if (struct_name == name_Vector)       return SkTypeID_Vector3;
    if (struct_name == name_Vector4)      return SkTypeID_Vector4;
    if (struct_name == name_Quat)         return SkTypeID_Rotation;
    if (struct_name == name_Rotator)      return SkTypeID_RotationAngles;
    if (struct_name == name_Transform)    return SkTypeID_Transform;
    if (struct_name == name_Color)        return SkTypeID_Color;
    if (struct_name == name_LinearColor)  return SkTypeID_Color;

    }

  if (property_p->IsA(UClassProperty::StaticClass()))       return SkTypeID_UClass;
  if (property_p->IsA(UObjectPropertyBase::StaticClass()))  return SkTypeID_UObject;

  // Didn't find a known type
  return SkTypeID_None;
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::get_skookum_property_type_name(UProperty * property_p)
  {
  eSkTypeID type_id = get_skookum_property_type(property_p);
  if (type_id == SkTypeID_UObject)
    {
    UObjectPropertyBase * object_property_p = Cast<UObjectPropertyBase>(property_p);
    m_used_classes.AddUnique(object_property_p->PropertyClass);
    return skookify_class_name(object_property_p->PropertyClass->GetName());
    }

  return ms_sk_type_id_names[type_id];
  }

//---------------------------------------------------------------------------------------

uint32 FSkookumScriptGenerator::get_skookum_string_crc(const FString & string)
  {
  char buffer[256];
  char * end_p = FPlatformString::Convert(buffer, sizeof(buffer), *string, string.Len());
  return FCrc::MemCrc32(buffer, end_p - buffer);
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::get_cpp_class_name(UClass * class_p)
  {
  return FString::Printf(TEXT("%s%s"), class_p->GetPrefixCPP(), *class_p->GetName());
  }

//---------------------------------------------------------------------------------------

FString FSkookumScriptGenerator::get_cpp_property_type_name(UProperty * property_p, uint32 port_flags /*= 0*/)
  {
  static FString decl_Enum(TEXT("enum "));
  static FString decl_Struct(TEXT("struct "));
  static FString decl_Class(TEXT("class "));
  static FString decl_TEnumAsByte(TEXT("TEnumAsByte<enum "));
  static FString decl_TSubclassOf(TEXT("TSubclassOf<class "));

  FString property_type_name = property_p->GetCPPType(NULL, port_flags);
  // Strip any forward declaration keywords
  if (property_type_name.StartsWith(decl_Enum) || property_type_name.StartsWith(decl_Struct) || property_type_name.StartsWith(decl_Class))
    {
    int FirstSpaceIndex = property_type_name.Find(TEXT(" "));
    property_type_name = property_type_name.Mid(FirstSpaceIndex + 1);
    }
  else if (property_type_name.StartsWith(decl_TEnumAsByte))
    {
    int FirstSpaceIndex = property_type_name.Find(TEXT(" "));
    property_type_name = TEXT("TEnumAsByte<") + property_type_name.Mid(FirstSpaceIndex + 1);
    }
  else if (property_type_name.StartsWith(decl_TSubclassOf))
    {
    int FirstSpaceIndex = property_type_name.Find(TEXT(" "));
    property_type_name = TEXT("TSubclassOf<") + property_type_name.Mid(FirstSpaceIndex + 1);
    }
  return property_type_name;
  }

//---------------------------------------------------------------------------------------

bool FSkookumScriptGenerator::save_header_if_changed(const FString & header_path, const FString & new_header_contents)
  {
  FString original_header_local;
  FFileHelper::LoadFileToString(original_header_local, *header_path);

  const bool has_changed = original_header_local.Len() == 0 || FCString::Strcmp(*original_header_local, *new_header_contents);
  if (has_changed)
    {
    // save the updated version to a tmp file so that the user can see what will be changing
    const FString temp_header_file_name = header_path + TEXT(".tmp");

    // delete any existing temp file
    IFileManager::Get().Delete(*temp_header_file_name, false, true);
    if (!FFileHelper::SaveStringToFile(new_header_contents, *temp_header_file_name))
      {
      UE_LOG(LogSkookumScriptGenerator, Warning, TEXT("Failed to save header export: '%s'"), *temp_header_file_name);
      }
    else
      {
      m_temp_headers.Add(temp_header_file_name);
      }
    }

  return has_changed;
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::rename_temp_files()
  {
  // Rename temp headers
  for (auto & temp_header_file_name : m_temp_headers)
    {
    FString file_name = temp_header_file_name.Replace(TEXT(".tmp"), TEXT(""));
    if (!IFileManager::Get().Move(*file_name, *temp_header_file_name, true, true))
      {
      UE_LOG(LogSkookumScriptGenerator, Error, TEXT("%s"), *FString::Printf(TEXT("Couldn't write file '%s'"), *file_name));
      }
    else
      {
      UE_LOG(LogSkookumScriptGenerator, Log, TEXT("Exported updated script header: %s"), *file_name);
      }
    }
  }

//=======================================================================================
// MethodBinding implementation
//=======================================================================================

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::MethodBinding::make_method(UFunction * function_p)
  {
  bool is_boolean = false;
  m_script_name = skookify_var_name(function_p->GetName(), &is_boolean);

  // If name starts with "get_", remove it
  if (m_script_name.RemoveFromStart(TEXT("get_"), ESearchCase::CaseSensitive))
    {
    // Append question mark if function returns a boolean
    if (!is_boolean)
      {
      UProperty * return_property_p = function_p->GetReturnProperty();
      if (return_property_p)
        {
        is_boolean = return_property_p->IsA(UBoolProperty::StaticClass());
        }
      }
    }
  else
    {
    // If name starts with "set_", remove it and append "_set" instead
    if (m_script_name.RemoveFromStart(TEXT("set_"), ESearchCase::CaseSensitive))
      {
      m_script_name.Append(TEXT("_set"));
      }
    }

  m_code_name = m_script_name;

  if (is_boolean)
    {
    m_script_name.AppendChar('?');
    m_code_name.Append(TEXT("_Q"));
    }
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::MethodBinding::make_property_getter(UProperty * property_p)
  {
  bool is_boolean = false;
  m_script_name = m_code_name = skookify_var_name(property_p->GetName(), &is_boolean);
  if (is_boolean)
    {
    m_script_name.AppendChar(TCHAR('?'));
    m_code_name.Append(TEXT("_Q"));
    }
  }

//---------------------------------------------------------------------------------------

void FSkookumScriptGenerator::MethodBinding::make_property_setter(UProperty * property_p)
  {
  m_script_name = skookify_var_name(property_p->GetName()) + TEXT("_set");
  m_code_name = m_script_name;
  }

